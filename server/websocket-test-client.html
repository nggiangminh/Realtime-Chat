<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Time Chat - WebSocket Test Client</title>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .section h3 {
            margin-top: 0;
            color: #555;
        }
        input[type="text"], input[type="number"] {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.connecting {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .messages {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #fafafa;
        }
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
        }
        .message.sent {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        .message.received {
            background-color: #f3e5f5;
            border-left: 4px solid #9c27b0;
        }
        .message.error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }
        .message.system {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
        }
        .token-input {
            width: 100%;
            font-family: monospace;
            font-size: 12px;
        }
        .flex {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .flex-1 {
            flex: 1;
        }
        .instructions {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .instructions ol {
            margin: 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîå Real Time Chat - WebSocket Test Client</h1>
            <p>Test g·ª≠i v√† nh·∫≠n tin nh·∫Øn real-time qua WebSocket</p>
        </div>

        <div class="instructions">
            <h3>üìã H∆∞·ªõng D·∫´n S·ª≠ d·ª•ng:</h3>
            <ol>
                <li>Click <strong>"üîß Test Server"</strong> ƒë·ªÉ ki·ªÉm tra server</li>
                <li>N·∫øu c√≥ CORS error ‚Üí <strong>Restart server</strong> b·∫±ng l·ªánh: <code>./mvnw spring-boot:run</code></li>
                <li>ƒêƒÉng nh·∫≠p qua Postman ƒë·ªÉ l·∫•y JWT token (kh√¥ng c√≥ "Bearer " prefix)</li>
                <li>Click <strong>"üîç Check Token"</strong> ƒë·ªÉ verify token</li>
                <li>Click <strong>"üîå Connect"</strong> ƒë·ªÉ k·∫øt n·ªëi WebSocket</li>
                <li>Nh·∫≠p Receiver ID v√† n·ªôi dung tin nh·∫Øn ƒë·ªÉ g·ª≠i</li>
            </ol>
            <div style="background-color: #fff3cd; padding: 10px; margin-top: 15px; border-radius: 5px;">
                <strong>‚ö†Ô∏è L∆∞u √Ω:</strong> N·∫øu g·∫∑p l·ªói "Failed to fetch", h√£y restart server ƒë·ªÉ apply CORS fix!
            </div>
        </div>

        <!-- Connection Section -->
        <div class="section">
            <h3>üîê K·∫øt N·ªëi WebSocket</h3>
            <div>
                <label for="token"><strong>JWT Token:</strong></label><br>
                <input type="text" id="token" class="token-input" placeholder="Paste JWT token t·ª´ Postman response /api/auth/login...">
            </div>
            <div class="flex" style="margin-top: 10px;">
                <button class="btn-primary" onclick="connect()">üîå Connect</button>
                <button class="btn-secondary" onclick="disconnect()">‚ùå Disconnect</button>
                <button class="btn-secondary" onclick="checkServer()">üîß Test Server</button>
                <button class="btn-secondary" onclick="validateToken()">üîç Check Token</button>
                <div id="status" class="status disconnected">‚≠ï Disconnected</div>
            </div>
        </div>

        <!-- Send Message Section -->
        <div class="section">
            <h3>üí¨ G·ª≠i Tin Nh·∫Øn</h3>
            <div class="flex">
                <label>Receiver ID:</label>
                <input type="number" id="receiverId" value="2" placeholder="ID c·ªßa user nh·∫≠n tin nh·∫Øn">
                <label>Message:</label>
                <input type="text" id="messageContent" class="flex-1" placeholder="Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n...">
                <button class="btn-success" onclick="sendMessage()">üì§ Send</button>
            </div>
        </div>

        <!-- Typing Section -->
        <div class="section">
            <h3>‚å®Ô∏è Typing Notification</h3>
            <div class="flex">
                <label>Notify Typing to User ID:</label>
                <input type="number" id="typingReceiverId" value="2">
                <button class="btn-primary" onclick="sendTyping(true)">‚å®Ô∏è Start Typing</button>
                <button class="btn-secondary" onclick="sendTyping(false)">‚èπÔ∏è Stop Typing</button>
            </div>
        </div>

        <!-- Messages Display -->
        <div class="section">
            <h3>üì® Tin Nh·∫Øn Real-time</h3>
            <button class="btn-secondary" onclick="clearMessages()" style="float: right;">üóëÔ∏è Clear</button>
            <div id="messages" class="messages">
                <div class="message system">
                    <strong>System:</strong> H√£y k·∫øt n·ªëi WebSocket ƒë·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n tin nh·∫Øn...
                </div>
            </div>
        </div>

        <!-- Connection Info -->
        <div class="section">
            <h3>‚ÑπÔ∏è Th√¥ng Tin K·∫øt N·ªëi</h3>
            <div id="connectionInfo">
                <p><strong>WebSocket URL:</strong> ws://localhost:8083/ws</p>
                <p><strong>Protocol:</strong> STOMP over SockJS</p>
                <p><strong>Send Destination:</strong> /app/chat.sendMessage</p>
                <p><strong>Receive Queue:</strong> /user/queue/messages</p>
                <p><strong>User Status Topic:</strong> /topic/users/status</p>
            </div>
        </div>
    </div>

    <script>
        let stompClient = null;
        let isConnected = false;

        // Debug function ƒë·ªÉ ki·ªÉm tra server
        function checkServer() {
            showSystemMessage('üîÑ ƒêang ki·ªÉm tra server...');
            fetch('http://localhost:8083/api/test/public', {
                mode: 'cors',
                method: 'GET'
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    showSystemMessage('‚úÖ Server ho·∫°t ƒë·ªông t·ªët: ' + data.message);
                })
                .catch(error => {
                    if (error.message.includes('Failed to fetch')) {
                        showSystemMessage('‚ùå CORS Error ho·∫∑c Server kh√¥ng ch·∫°y. H√£y restart server sau khi s·ª≠a CORS!');
                        showSystemMessage('üí° Tip: Ch·∫°y l·∫°i server b·∫±ng l·ªánh: ./mvnw spring-boot:run');
                    } else {
                        showSystemMessage('‚ùå Server l·ªói: ' + error.message);
                    }
                    console.error('Server check error:', error);
                });
        }

        // Debug function ƒë·ªÉ ki·ªÉm tra token
        function validateToken() {
            const token = document.getElementById('token').value.trim();
            if (!token) {
                showSystemMessage('‚ö†Ô∏è Ch∆∞a c√≥ token ƒë·ªÉ ki·ªÉm tra');
                return;
            }

            showSystemMessage('üîÑ ƒêang ki·ªÉm tra token...');
            fetch('http://localhost:8083/api/auth/me', {
                mode: 'cors',
                method: 'GET',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json'
                }
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.result === 'SUCCESS') {
                        showSystemMessage('‚úÖ Token h·ª£p l·ªá cho user: ' + data.data.displayName + ' (ID: ' + data.data.id + ')');
                    } else {
                        showSystemMessage('‚ùå Token kh√¥ng h·ª£p l·ªá: ' + data.message);
                    }
                })
                .catch(error => {
                    if (error.message.includes('Failed to fetch')) {
                        showSystemMessage('‚ùå CORS Error! Server c·∫ßn restart ƒë·ªÉ apply CORS fix!');
                    } else if (error.message.includes('401')) {
                        showSystemMessage('‚ùå Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n!');
                    } else {
                        showSystemMessage('‚ùå L·ªói ki·ªÉm tra token: ' + error.message);
                    }
                    console.error('Token validation error:', error);
                });
        }

        function connect() {
            const token = document.getElementById('token').value.trim();
            if (!token) {
                alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p JWT token tr∆∞·ªõc!');
                return;
            }

            if (isConnected) {
                alert('‚ö†Ô∏è ƒê√£ k·∫øt n·ªëi r·ªìi!');
                return;
            }

            // Ki·ªÉm tra token tr∆∞·ªõc khi connect
            showSystemMessage('üîÑ Ki·ªÉm tra token tr∆∞·ªõc khi k·∫øt n·ªëi...');
            fetch('http://localhost:8083/api/auth/me', {
                headers: {
                    'Authorization': 'Bearer ' + token
                }
            })
                .then(response => response.json())
                .then(data => {
                    if (data.result !== 'SUCCESS') {
                        showMessage('error', { content: '‚ùå Token kh√¥ng h·ª£p l·ªá: ' + data.message });
                        return;
                    }
                    showSystemMessage('‚úÖ Token h·ª£p l·ªá cho: ' + data.data.displayName);
                    // Token OK, ti·∫øp t·ª•c connect WebSocket
                    doWebSocketConnect(token);
                })
                .catch(error => {
                    showMessage('error', { content: '‚ùå Kh√¥ng th·ªÉ ki·ªÉm tra token: ' + error.message });
                });
        }

        function doWebSocketConnect(token) {

            showSystemMessage('üîÑ ƒêang k·∫øt n·ªëi WebSocket...');
            updateStatus('connecting', 'üîÑ Connecting...');

            try {
                const socket = new SockJS('http://localhost:8083/ws');
                stompClient = Stomp.over(socket);

                // Enable debug
                stompClient.debug = function(str) {
                    console.log('STOMP: ' + str);
                };

                const headers = {
                    'Authorization': 'Bearer ' + token
                };

                stompClient.connect(headers, function(frame) {
                    console.log('‚úÖ WebSocket Connected: ' + frame);
                    isConnected = true;
                    updateStatus('connected', '‚úÖ Connected');
                    showSystemMessage('üéâ K·∫øt n·ªëi WebSocket th√†nh c√¥ng!');

                    // Subscribe to receive messages
                    stompClient.subscribe('/user/queue/messages', function(message) {
                        console.log('üì• Received message:', message.body);
                        const messageData = JSON.parse(message.body);
                        showMessage('received', messageData);
                    });

                    // Subscribe to typing notifications
                    stompClient.subscribe('/user/queue/typing', function(notification) {
                        console.log('‚å®Ô∏è Received typing:', notification.body);
                        const notificationData = JSON.parse(notification.body);
                        showTypingNotification(notificationData);
                    });

                    // Subscribe to user status updates
                    stompClient.subscribe('/topic/users/status', function(status) {
                        console.log('üë• Received status:', status.body);
                        const statusData = JSON.parse(status.body);
                        showUserStatusUpdate(statusData);
                    });

                    // Subscribe to errors
                    stompClient.subscribe('/user/queue/errors', function(error) {
                        console.log('‚ùå Received error:', error.body);
                        showMessage('error', { content: error.body });
                    });

                }, function(error) {
                    console.error('‚ùå WebSocket Connection Error:', error);
                    console.error('Error details:', JSON.stringify(error));
                    isConnected = false;
                    updateStatus('disconnected', '‚ùå Connection Failed');

                    let errorMessage = 'K·∫øt n·ªëi th·∫•t b·∫°i';
                    if (error.headers && error.headers.message) {
                        errorMessage += ': ' + error.headers.message;
                    } else if (error.message) {
                        errorMessage += ': ' + error.message;
                    } else {
                        errorMessage += ': ' + JSON.stringify(error);
                    }

                    showMessage('error', { content: errorMessage });

                    // Ki·ªÉm tra c√°c l·ªói th∆∞·ªùng g·∫∑p
                    if (JSON.stringify(error).includes('403') || JSON.stringify(error).includes('Forbidden')) {
                        showMessage('error', { content: 'üîê JWT Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n!' });
                    } else if (JSON.stringify(error).includes('404')) {
                        showMessage('error', { content: 'üîç WebSocket endpoint kh√¥ng t·ªìn t·∫°i. Ki·ªÉm tra server config!' });
                    } else if (JSON.stringify(error).includes('Connection refused')) {
                        showMessage('error', { content: 'üö´ Server kh√¥ng ch·∫°y ho·∫∑c port 8083 b·ªã block!' });
                    }
                });

            } catch (error) {
                console.error('‚ùå Error creating WebSocket:', error);
                updateStatus('disconnected', '‚ùå Error');
                showMessage('error', { content: 'L·ªói t·∫°o WebSocket: ' + error.message });
            }
        }

        function disconnect() {
            if (stompClient !== null && isConnected) {
                stompClient.disconnect(function() {
                    console.log('üëã WebSocket Disconnected');
                    isConnected = false;
                    updateStatus('disconnected', '‚≠ï Disconnected');
                    showSystemMessage('üëã ƒê√£ ng·∫Øt k·∫øt n·ªëi WebSocket');
                });
            } else {
                alert('‚ö†Ô∏è Ch∆∞a k·∫øt n·ªëi!');
            }
        }

        function sendMessage() {
            if (!isConnected || stompClient === null) {
                alert('‚ö†Ô∏è Vui l√≤ng k·∫øt n·ªëi WebSocket tr∆∞·ªõc!');
                return;
            }

            const receiverId = document.getElementById('receiverId').value.trim();
            const content = document.getElementById('messageContent').value.trim();

            if (!receiverId || !content) {
                alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß Receiver ID v√† n·ªôi dung tin nh·∫Øn!');
                return;
            }

            const message = {
                receiverId: parseInt(receiverId),
                content: content
            };

            try {
                stompClient.send('/app/chat.sendMessage', {}, JSON.stringify(message));
                showMessage('sent', {
                    receiverId: receiverId,
                    content: content,
                    sentAt: new Date().toISOString()
                });

                // Clear message input
                document.getElementById('messageContent').value = '';
                console.log('üì§ Message sent:', message);

            } catch (error) {
                console.error('‚ùå Error sending message:', error);
                showMessage('error', { content: 'L·ªói g·ª≠i tin nh·∫Øn: ' + error.message });
            }
        }

        function sendTyping(isTyping) {
            if (!isConnected || stompClient === null) {
                alert('‚ö†Ô∏è Vui l√≤ng k·∫øt n·ªëi WebSocket tr∆∞·ªõc!');
                return;
            }

            const receiverId = document.getElementById('typingReceiverId').value.trim();

            if (!receiverId) {
                alert('‚ö†Ô∏è Vui l√≤ng nh·∫≠p Receiver ID!');
                return;
            }

            const typingNotification = {
                receiverId: parseInt(receiverId),
                isTyping: isTyping
            };

            try {
                stompClient.send('/app/chat.typing', {}, JSON.stringify(typingNotification));
                showSystemMessage(`‚å®Ô∏è ƒê√£ g·ª≠i th√¥ng b√°o ${isTyping ? 'b·∫Øt ƒë·∫ßu' : 'k·∫øt th√∫c'} typing t·ªõi user ${receiverId}`);
                console.log('‚å®Ô∏è Typing notification sent:', typingNotification);

            } catch (error) {
                console.error('‚ùå Error sending typing notification:', error);
                showMessage('error', { content: 'L·ªói g·ª≠i th√¥ng b√°o typing: ' + error.message });
            }
        }

        function updateStatus(type, message) {
            const statusElement = document.getElementById('status');
            statusElement.className = `status ${type}`;
            statusElement.textContent = message;
        }

        function showMessage(type, messageData) {
            const messagesDiv = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}`;

            const timestamp = new Date().toLocaleTimeString('vi-VN');

            if (type === 'sent') {
                messageElement.innerHTML = `
                    <div><strong>üì§ [SENT] ${timestamp}</strong></div>
                    <div>To User ID: <strong>${messageData.receiverId}</strong></div>
                    <div>Content: <em>"${messageData.content}"</em></div>
                `;
            } else if (type === 'received') {
                messageElement.innerHTML = `
                    <div><strong>üì• [RECEIVED] ${timestamp}</strong></div>
                    <div>From: <strong>${messageData.senderDisplayName}</strong> (ID: ${messageData.senderId})</div>
                    <div>Content: <em>"${messageData.content}"</em></div>
                    <div>Sent At: <small>${new Date(messageData.sentAt).toLocaleString('vi-VN')}</small></div>
                    <div>Read Status: ${messageData.isRead ? '‚úÖ Read' : '‚è≥ Unread'}</div>
                `;
            } else if (type === 'error') {
                messageElement.innerHTML = `
                    <div><strong>‚ùå [ERROR] ${timestamp}</strong></div>
                    <div style="color: red;">${messageData.content}</div>
                `;
            }

            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function showSystemMessage(content) {
            const messagesDiv = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = 'message system';

            const timestamp = new Date().toLocaleTimeString('vi-VN');
            messageElement.innerHTML = `
                <div><strong>üîî [SYSTEM] ${timestamp}</strong></div>
                <div>${content}</div>
            `;

            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function showTypingNotification(notificationData) {
            const timestamp = new Date().toLocaleTimeString('vi-VN');
            showSystemMessage(`‚å®Ô∏è ${notificationData.senderDisplayName} ${notificationData.isTyping ? 'ƒëang g√µ...' : 'ƒë√£ d·ª´ng g√µ'}`);
        }

        function showUserStatusUpdate(statusData) {
            const timestamp = new Date().toLocaleTimeString('vi-VN');
            const statusIcon = statusData.status === 'ONLINE' ? 'üü¢' : 'üî¥';
            showSystemMessage(`${statusIcon} ${statusData.displayName} ƒë√£ ${statusData.status === 'ONLINE' ? 'online' : 'offline'}`);
        }

        function clearMessages() {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = `
                <div class="message system">
                    <strong>System:</strong> ƒê√£ x√≥a t·∫•t c·∫£ tin nh·∫Øn. S·∫µn s√†ng nh·∫≠n tin nh·∫Øn m·ªõi...
                </div>
            `;
        }

        // Enter key to send message
        document.getElementById('messageContent').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Auto-focus token input
        document.getElementById('token').focus();

        // Show initial system message
        window.addEventListener('load', function() {
            showSystemMessage('üöÄ WebSocket Test Client ƒë√£ s·∫µn s√†ng! H√£y nh·∫≠p JWT token v√† k·∫øt n·ªëi.');
        });
    </script>
</body>
</html>
